import numpy as np
import pandas as pd
from scipy.signal import butter, filtfilt
from scipy.optimize import curve_fit, OptimizeWarning
import os
import math
import argparse
from pathlib import Path
import textwrap

import matplotlib
# Force interactive backend on Windows
if os.name == 'nt':  # Windows
    matplotlib.use('TkAgg')  # Use Tkinter backend which supports interactive plots
import matplotlib.pyplot as plt

# Import Siglent binary parser (if available)
try:
    from siglent_parser import SiglentBinaryParser
    SIGLENT_PARSER_AVAILABLE = True
except ImportError:
    SIGLENT_PARSER_AVAILABLE = False

# Import cycle statistics module
try:
    from cycle_statistics import analyze_cycles, print_cycle_analysis_summary, compare_cycle_statistics
    CYCLE_STATISTICS_AVAILABLE = True
except ImportError:
    CYCLE_STATISTICS_AVAILABLE = False
    print("Warning: cycle_statistics module not available. Cycle analysis disabled.")

# --- Configuration ---
CSV_FILE = r"C:\Users\DavidLin\Desktop\E-field Data\Data\123.csv"
# Channel definitions:
# Channel 1: E-field sensor output
# Channel 3: Mains voltage reference
AMPLIFICATION_CH1 = 1    # E-field sensor output - no additional amplification needed
AMPLIFICATION_CH3 = 1    # Mains voltage reference - no additional amplification needed  
DOWNSAMPLE_FACTOR = 100  # Downsample factor to speed processing; increased for large datasets
FILTER_ORDER = 4
FILTER_CUTOFF_HZ = None  # None = auto cutoff at fs/10, or specify as needed
BINARY_DATA_DIR = "data"  # Directory containing Siglent binary data files

# Cycle analysis configuration
CYCLE_DETECTION_METHOD = 'peak_to_peak'  # 'zero_crossing' or 'peak_to_peak'
CYCLE_ANALYSIS_ENABLED = True  # Enable/disable cycle analysis by default

# --- Helper functions ---

def read_oscilloscope_csv(file_path):
    """
    Read oscilloscope CSV, skipping metadata lines until data header line 'Second'.
    Returns pandas DataFrame with time and voltage columns.
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()

    # Find index where data actually starts (line starting with "Second")
    for i, line in enumerate(lines):
        if line.startswith("Second"):
            start_line = i
            break

    # Read CSV from the data header line onward
    df = pd.read_csv(file_path, skiprows=start_line)
    df.columns = df.columns.str.strip()  # Clean header whitespace
    return df

def amplify_signal(signal, factor):
    """Amplify signal by a constant factor."""
    return signal * factor

def downsample_signal(signal, factor):
    """Downsample signal by integer factor."""
    if factor <= 1:
        return signal
    return signal[::factor]

def butter_lowpass(cutoff, fs, order=4):
    """Create a Butterworth lowpass filter."""
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def zero_phase_filter(signal, fs, cutoff=None, order=4):
    """
    Apply zero-phase Butterworth lowpass filter using filtfilt,
    with cutoff default to fs/10 if None.
    """
    if cutoff is None:
        cutoff = fs / 10
    b, a = butter_lowpass(cutoff, fs, order=order)
    return filtfilt(b, a, signal)

def sine_function(t, A, f, phi, offset):
    """Sinusoidal model: A*sin(2*pi*f*t + phi) + offset."""
    return A * np.sin(2 * np.pi * f * t + phi) + offset

def fit_sine_to_signal(time, signal):
    """
    Fit sinusoidal function to the input signal.
    Returns dictionary of amplitude, frequency, phase, offset, and fit success flag.
    """
    A_guess = (np.max(signal) - np.min(signal)) / 2
    offset_guess = np.mean(signal)

    # FFT to estimate frequency
    fft = np.fft.rfft(signal - offset_guess)
    freqs = np.fft.rfftfreq(len(signal), d=time[1] - time[0])
    f_guess = freqs[np.argmax(np.abs(fft))]
    phi_guess = 0

    try:
        # Use more relaxed fitting parameters and suppress covariance warnings
        import warnings
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=RuntimeWarning)
            warnings.simplefilter("ignore", category=UserWarning)
            popt, _ = curve_fit(sine_function, time, signal,
                               p0=[A_guess, f_guess, phi_guess, offset_guess],
                               maxfev=10000,
                               bounds=([-np.inf, 0, -2*np.pi, -np.inf], 
                                      [np.inf, np.inf, 2*np.pi, np.inf]))
        A, f, phi, offset = popt
        fit_success = True
    except (RuntimeError, ValueError, OptimizeWarning) as e:
        print(f"Warning: Sine fit failed for signal - {str(e)}")
        A, f, phi, offset = np.nan, np.nan, np.nan, np.nan
        fit_success = False

    return {'amplitude': A, 'frequency': f, 'phase': phi, 'offset': offset, 'fit_success': fit_success}

def rms(signal):
    """Calculate RMS value of a signal."""
    return np.sqrt(np.mean(signal ** 2))

def remove_dc_offset_advanced(signal, method='detrend', window_size=None):
    """
    Advanced DC offset removal with multiple methods.
    
    Args:
        signal: Input signal
        method: 'mean', 'median', 'detrend', 'highpass', 'rolling_mean', 'polynomial'
        window_size: For rolling methods (default: 10% of signal length)
    
    Returns:
        tuple: (dc_removed_signal, dc_offset_info)
    """
    from scipy import signal as scipy_signal
    from scipy.signal import detrend
    
    if window_size is None:
        window_size = max(100, len(signal) // 10)  # 10% of signal length, minimum 100
    
    original_signal = signal.copy()
    
    if method == 'mean':
        # Simple mean removal
        dc_offset = np.mean(signal)
        clean_signal = signal - dc_offset
        info = f"Simple mean removal: DC offset = {dc_offset:.6f}V"
        
    elif method == 'median':
        # Robust median removal (better for outliers)
        dc_offset = np.median(signal)
        clean_signal = signal - dc_offset
        info = f"Median removal: DC offset = {dc_offset:.6f}V"
        
    elif method == 'detrend':
        # Remove linear trend + mean (scipy detrend)
        clean_signal = detrend(signal, type='linear')
        dc_offset = np.mean(signal) - np.mean(clean_signal)
        info = f"Linear detrend: Removed trend + DC offset = {dc_offset:.6f}V"
        
    elif method == 'highpass':
        # High-pass filter to remove DC and very low frequencies
        fs = 100000  # Assume 100kHz after downsampling (adjust if needed)
        cutoff = 1.0  # 1 Hz highpass cutoff
        nyq = 0.5 * fs
        normal_cutoff = cutoff / nyq
        b, a = scipy_signal.butter(4, normal_cutoff, btype='high', analog=False)
        clean_signal = scipy_signal.filtfilt(b, a, signal)
        dc_offset = np.mean(signal) - np.mean(clean_signal)
        info = f"High-pass filter ({cutoff}Hz): Removed DC = {dc_offset:.6f}V"
        
    elif method == 'rolling_mean':
        # Rolling mean subtraction (adaptive DC removal)
        # Use pandas-style rolling mean
        try:
            import pandas as pd
            rolling_dc = pd.Series(signal).rolling(window=window_size, center=True, min_periods=1).mean()
            clean_signal = signal - rolling_dc.values
            dc_offset = np.mean(rolling_dc)
        except ImportError:
            # Fallback: simple convolution-based rolling mean
            kernel = np.ones(window_size) / window_size
            rolling_dc = np.convolve(signal, kernel, mode='same')
            clean_signal = signal - rolling_dc
            dc_offset = np.mean(rolling_dc)
        info = f"Rolling mean (window={window_size}): Average DC = {dc_offset:.6f}V"
        
    elif method == 'polynomial':
        # Polynomial detrending (removes complex baselines)
        x = np.arange(len(signal))
        coeffs = np.polyfit(x, signal, deg=3)  # 3rd order polynomial
        baseline = np.polyval(coeffs, x)
        clean_signal = signal - baseline
        dc_offset = np.mean(baseline)
        info = f"Polynomial detrend (3rd order): Average baseline = {dc_offset:.6f}V"
        
    else:
        raise ValueError(f"Unknown DC removal method: {method}")
    
    # Calculate improvement metrics
    original_std = np.std(original_signal)
    clean_std = np.std(clean_signal)
    original_mean = np.mean(original_signal)
    clean_mean = np.mean(clean_signal)
    
    dc_info = {
        'method': method,
        'original_mean': original_mean,
        'clean_mean': clean_mean,
        'dc_removed': original_mean - clean_mean,
        'original_std': original_std,
        'clean_std': clean_std,
        'snr_improvement': clean_std / original_std if original_std > 0 else 1.0,
        'description': info
    }
    
    return clean_signal, dc_info

def test_dc_removal_methods(signal, time_array, signal_name):
    """
    Test multiple DC removal methods and recommend the best one.
    """
    methods = ['mean', 'median', 'detrend', 'highpass', 'rolling_mean']
    results = {}
    
    print(f"\nüß™ TESTING DC REMOVAL METHODS for {signal_name}:")
    print(f"   Original signal: mean={np.mean(signal):.6f}V, std={np.std(signal):.6f}V")
    
    for method in methods:
        try:
            clean_signal, dc_info = remove_dc_offset_advanced(signal, method)
            
            # Count zero crossings after DC removal
            zero_crossings = count_zero_crossings_simple(clean_signal)
            
            results[method] = {
                'clean_signal': clean_signal,
                'dc_info': dc_info,
                'zero_crossings': zero_crossings,
                'final_mean': np.mean(clean_signal),
                'final_std': np.std(clean_signal),
                'abs_mean': abs(np.mean(clean_signal))
            }
            
            print(f"   {method:12}: mean={results[method]['final_mean']:+.6f}V, "
                  f"std={results[method]['final_std']:.6f}V, crossings={zero_crossings}")
            
        except Exception as e:
            print(f"   {method:12}: FAILED - {str(e)}")
            results[method] = None
    
    # Find best method (lowest absolute mean, reasonable zero crossings)
    duration = time_array[-1] - time_array[0]
    expected_crossings = duration * 60 * 2  # ~120 for 1 second at 60Hz
    
    best_method = None
    best_score = float('inf')
    
    for method, result in results.items():
        if result is None:
            continue
            
        # Scoring: penalize large DC offset and wrong number of crossings
        dc_penalty = abs(result['final_mean']) * 1000  # Heavily penalize remaining DC
        crossing_penalty = abs(result['zero_crossings'] - expected_crossings) / 10
        score = dc_penalty + crossing_penalty
        
        if score < best_score:
            best_score = score
            best_method = method
    
    if best_method:
        print(f"\n   üèÜ BEST METHOD: {best_method}")
        print(f"      {results[best_method]['dc_info']['description']}")
        print(f"      Final: mean={results[best_method]['final_mean']:+.6f}V, "
              f"crossings={results[best_method]['zero_crossings']} (expected ~{expected_crossings:.0f})")
        
        return results[best_method]['clean_signal'], best_method, results[best_method]['dc_info']
    else:
        print(f"   ‚ùå No suitable DC removal method found")
        return signal, 'none', {'description': 'No DC removal applied'}

def count_zero_crossings_simple(signal):
    """Simple zero crossing counter for testing DC removal methods."""
    crossings = 0
    for i in range(1, len(signal)):
        if (signal[i-1] <= 0 and signal[i] > 0) or (signal[i-1] >= 0 and signal[i] < 0):
            crossings += 1
    return crossings

def diagnose_zero_crossing_issues(ch1_signal, ch3_signal, time_array, signal_type):
    """
    Diagnose why there are different numbers of zero crossings between signals.
    """
    from scipy import signal as scipy_signal
    
    # Calculate sampling frequency
    fs = 1.0 / np.mean(np.diff(time_array))
    duration = time_array[-1] - time_array[0]
    
    # Remove DC components
    ch1_ac = ch1_signal - np.mean(ch1_signal)
    ch3_ac = ch3_signal - np.mean(ch3_signal)
    
    print(f"\nüîç ZERO CROSSING DIAGNOSTIC for {signal_type}:")
    print(f"   Data characteristics:")
    print(f"     Duration: {duration:.3f} seconds")
    print(f"     Sample rate: {fs:.1f} Hz")
    print(f"     Expected ~60Hz cycles: {duration * 60:.1f}")
    print(f"     Expected zero crossings: {duration * 60 * 2:.0f} (2 per cycle)")
    
    print(f"\n   Signal statistics:")
    print(f"     E-field: min={np.min(ch1_signal):.6f}V, max={np.max(ch1_signal):.6f}V, mean={np.mean(ch1_signal):.6f}V")
    print(f"     Mains:   min={np.min(ch3_signal):.3f}V, max={np.max(ch3_signal):.3f}V, mean={np.mean(ch3_signal):.3f}V")
    print(f"     E-field AC: min={np.min(ch1_ac):.6f}V, max={np.max(ch1_ac):.6f}V")
    print(f"     Mains AC:   min={np.min(ch3_ac):.3f}V, max={np.max(ch3_ac):.3f}V")
    
    # Count all zero crossings (both positive and negative going)
    def count_all_zero_crossings(signal_ac):
        crossings = []
        for i in range(1, len(signal_ac)):
            if (signal_ac[i-1] <= 0 and signal_ac[i] > 0) or (signal_ac[i-1] >= 0 and signal_ac[i] < 0):
                zero_time = time_array[i-1] + (0 - signal_ac[i-1]) / (signal_ac[i] - signal_ac[i-1]) * (time_array[i] - time_array[i-1])
                crossings.append((zero_time, 'pos' if signal_ac[i] > 0 else 'neg'))
        return crossings
    
    def count_positive_zero_crossings(signal_ac):
        crossings = []
        for i in range(1, len(signal_ac)):
            if signal_ac[i-1] <= 0 and signal_ac[i] > 0:
                zero_time = time_array[i-1] + (0 - signal_ac[i-1]) / (signal_ac[i] - signal_ac[i-1]) * (time_array[i] - time_array[i-1])
                crossings.append(zero_time)
        return crossings
    
    # Count zero crossings
    ch1_all_crossings = count_all_zero_crossings(ch1_ac)
    ch3_all_crossings = count_all_zero_crossings(ch3_ac)
    ch1_pos_crossings = count_positive_zero_crossings(ch1_ac)
    ch3_pos_crossings = count_positive_zero_crossings(ch3_ac)
    
    print(f"\n   Zero crossing counts:")
    print(f"     E-field: {len(ch1_all_crossings)} total, {len(ch1_pos_crossings)} positive-going")
    print(f"     Mains:   {len(ch3_all_crossings)} total, {len(ch3_pos_crossings)} positive-going")
    
    # Check if signals are actually periodic
    fft_ch1 = np.fft.rfft(ch1_ac)
    fft_ch3 = np.fft.rfft(ch3_ac)
    freqs = np.fft.rfftfreq(len(ch1_ac), d=1/fs)
    
    ch1_peak_idx = np.argmax(np.abs(fft_ch1))
    ch3_peak_idx = np.argmax(np.abs(fft_ch3))
    ch1_freq = freqs[ch1_peak_idx]
    ch3_freq = freqs[ch3_peak_idx]
    
    print(f"\n   Frequency analysis:")
    print(f"     E-field dominant frequency: {ch1_freq:.3f} Hz")
    print(f"     Mains dominant frequency:   {ch3_freq:.3f} Hz")
    
    # Expected vs actual crossings
    expected_crossings_ch1 = duration * ch1_freq * 2
    expected_crossings_ch3 = duration * ch3_freq * 2
    
    print(f"\n   Expected vs actual crossings:")
    print(f"     E-field: expected {expected_crossings_ch1:.0f}, got {len(ch1_all_crossings)} ({len(ch1_all_crossings)/expected_crossings_ch1*100:.1f}%)")
    print(f"     Mains:   expected {expected_crossings_ch3:.0f}, got {len(ch3_all_crossings)} ({len(ch3_all_crossings)/expected_crossings_ch3*100:.1f}%)")
    
    # Check signal quality - look for distortion, clipping, etc.
    def check_signal_quality(signal, signal_ac, name):
        # Check for clipping (signal stuck at extremes)
        threshold = 0.95 * (np.max(signal) - np.min(signal))
        clipped_high = np.sum(signal > (np.min(signal) + threshold))
        clipped_low = np.sum(signal < (np.min(signal) + 0.05 * (np.max(signal) - np.min(signal))))
        
        # Check for flat regions (stuck values)
        diff = np.diff(signal)
        flat_samples = np.sum(np.abs(diff) < np.std(diff) * 0.01)
        
        print(f"     {name} quality:")
        print(f"       Potentially clipped samples: {clipped_high + clipped_low} ({(clipped_high + clipped_low)/len(signal)*100:.2f}%)")
        print(f"       Flat/stuck samples: {flat_samples} ({flat_samples/len(signal)*100:.2f}%)")
        
        # Check for DC offset issues
        dc_offset = np.mean(signal)
        ac_amplitude = np.std(signal_ac)
        print(f"       DC offset: {dc_offset:.6f}V")
        print(f"       AC amplitude (std): {ac_amplitude:.6f}V")
        
        if abs(dc_offset) > ac_amplitude:
            print(f"       ‚ö†Ô∏è Large DC offset detected - may affect zero crossing detection")
        
        return {
            'clipped_samples': clipped_high + clipped_low,
            'flat_samples': flat_samples,
            'dc_offset': dc_offset,
            'ac_amplitude': ac_amplitude
        }
    
    print(f"\n   Signal quality assessment:")
    ch1_quality = check_signal_quality(ch1_signal, ch1_ac, "E-field")
    ch3_quality = check_signal_quality(ch3_signal, ch3_ac, "Mains")
    
    # Look at the first few zero crossings to see timing
    print(f"\n   First 10 zero crossings timing:")
    print(f"     E-field positive crossings: {[f'{t:.6f}s' for t in ch1_pos_crossings[:10]]}")
    print(f"     Mains positive crossings:   {[f'{t:.6f}s' for t in ch3_pos_crossings[:10]]}")
    
    if len(ch1_pos_crossings) > 1:
        ch1_periods = np.diff(ch1_pos_crossings)
        print(f"     E-field periods: mean={np.mean(ch1_periods):.6f}s, std={np.std(ch1_periods):.6f}s")
    
    if len(ch3_pos_crossings) > 1:
        ch3_periods = np.diff(ch3_pos_crossings)
        print(f"     Mains periods: mean={np.mean(ch3_periods):.6f}s, std={np.std(ch3_periods):.6f}s")
    
    # Recommendations
    print(f"\n   üéØ DIAGNOSIS SUMMARY:")
    if len(ch1_all_crossings) < expected_crossings_ch1 * 0.8:
        print(f"     ‚ùå E-field: Missing {expected_crossings_ch1 - len(ch1_all_crossings):.0f} expected crossings")
        if ch1_quality['clipped_samples'] > len(ch1_signal) * 0.01:
            print(f"       ‚Üí Likely cause: Signal clipping/saturation")
        elif ch1_quality['flat_samples'] > len(ch1_signal) * 0.05:
            print(f"       ‚Üí Likely cause: Signal distortion or ADC issues")
        else:
            print(f"       ‚Üí Likely cause: Very low amplitude or high noise")
    
    if len(ch3_all_crossings) < expected_crossings_ch3 * 0.8:
        print(f"     ‚ùå Mains: Missing {expected_crossings_ch3 - len(ch3_all_crossings):.0f} expected crossings")
        if ch3_quality['clipped_samples'] > len(ch3_signal) * 0.01:
            print(f"       ‚Üí Likely cause: Signal clipping/saturation")
        elif ch3_quality['flat_samples'] > len(ch3_signal) * 0.05:
            print(f"       ‚Üí Likely cause: Signal distortion")
    
    if abs(len(ch1_all_crossings) - len(ch3_all_crossings)) > 10:
        print(f"     ‚ö†Ô∏è Large discrepancy in zero crossing counts between signals")
        print(f"       ‚Üí This suggests different signal characteristics or quality issues")
    
    return {
        'ch1_crossings': len(ch1_all_crossings),
        'ch3_crossings': len(ch3_all_crossings),
        'ch1_pos_crossings': len(ch1_pos_crossings),
        'ch3_pos_crossings': len(ch3_pos_crossings),
        'expected_ch1': expected_crossings_ch1,
        'expected_ch3': expected_crossings_ch3,
        'ch1_quality': ch1_quality,
        'ch3_quality': ch3_quality
    }

def analyze_cycle_by_cycle_phase(ch1_signal, ch3_signal, time_array, signal_type):
    """
    Analyze phase relationship on a cycle-by-cycle basis using zero-crossing detection.
    """
    from scipy import signal as scipy_signal
    
    # Calculate sampling frequency
    fs = 1.0 / np.mean(np.diff(time_array))
    
    # Remove DC components
    ch1_ac = ch1_signal - np.mean(ch1_signal)
    ch3_ac = ch3_signal - np.mean(ch3_signal)
    
    # Find zero crossings for both signals (positive-going)
    ch1_zero_crossings = []
    ch3_zero_crossings = []
    
    # Find positive-going zero crossings for E-field (ch1)
    for i in range(1, len(ch1_ac)):
        if ch1_ac[i-1] <= 0 and ch1_ac[i] > 0:
            # Interpolate exact zero crossing
            zero_time = time_array[i-1] + (0 - ch1_ac[i-1]) / (ch1_ac[i] - ch1_ac[i-1]) * (time_array[i] - time_array[i-1])
            ch1_zero_crossings.append(zero_time)
    
    # Find positive-going zero crossings for Mains (ch3)
    for i in range(1, len(ch3_ac)):
        if ch3_ac[i-1] <= 0 and ch3_ac[i] > 0:
            # Interpolate exact zero crossing
            zero_time = time_array[i-1] + (0 - ch3_ac[i-1]) / (ch3_ac[i] - ch3_ac[i-1]) * (time_array[i] - time_array[i-1])
            ch3_zero_crossings.append(zero_time)
    
    if len(ch1_zero_crossings) < 2 or len(ch3_zero_crossings) < 2:
        return "‚ùå Insufficient zero crossings detected for cycle analysis", None
    
    # Match up cycles - find closest mains crossing for each E-field crossing
    cycle_phase_differences = []
    cycle_time_delays = []
    cycle_frequencies_ch1 = []
    cycle_frequencies_ch3 = []
    
    for i in range(len(ch1_zero_crossings)):
        ch1_time = ch1_zero_crossings[i]
        
        # Find closest mains zero crossing
        closest_ch3_idx = None
        min_time_diff = float('inf')
        
        for j, ch3_time in enumerate(ch3_zero_crossings):
            time_diff = abs(ch3_time - ch1_time)
            if time_diff < min_time_diff:
                min_time_diff = time_diff
                closest_ch3_idx = j
        
        if closest_ch3_idx is not None and min_time_diff < 0.01:  # Within 10ms
            ch3_time = ch3_zero_crossings[closest_ch3_idx]
            time_delay = ch1_time - ch3_time
            
            # Calculate frequencies for this cycle (if we have next crossings)
            if i < len(ch1_zero_crossings) - 1:
                ch1_period = ch1_zero_crossings[i+1] - ch1_zero_crossings[i]
                ch1_freq = 1.0 / ch1_period if ch1_period > 0 else 0
                cycle_frequencies_ch1.append(ch1_freq)
            else:
                ch1_freq = cycle_frequencies_ch1[-1] if cycle_frequencies_ch1 else 60.0
                
            if closest_ch3_idx < len(ch3_zero_crossings) - 1:
                ch3_period = ch3_zero_crossings[closest_ch3_idx+1] - ch3_zero_crossings[closest_ch3_idx]
                ch3_freq = 1.0 / ch3_period if ch3_period > 0 else 0
                cycle_frequencies_ch3.append(ch3_freq)
            else:
                ch3_freq = cycle_frequencies_ch3[-1] if cycle_frequencies_ch3 else 60.0
            
            # Convert time delay to phase difference
            avg_freq = (ch1_freq + ch3_freq) / 2
            phase_diff_deg = (time_delay * avg_freq * 360) % 360
            
            # Normalize to -180 to +180 range
            if phase_diff_deg > 180:
                phase_diff_deg -= 360
                
            cycle_phase_differences.append(phase_diff_deg)
            cycle_time_delays.append(time_delay * 1000)  # Convert to ms
    
    if len(cycle_phase_differences) < 3:
        return "‚ùå Insufficient cycle matches for statistical analysis", None
    
    # Calculate statistics
    phase_diffs = np.array(cycle_phase_differences)
    time_delays = np.array(cycle_time_delays)
    
    stats = {
        'num_cycles': len(cycle_phase_differences),
        'phase_mean': np.mean(phase_diffs),
        'phase_std': np.std(phase_diffs),
        'phase_median': np.median(phase_diffs),
        'phase_min': np.min(phase_diffs),
        'phase_max': np.max(phase_diffs),
        'phase_range': np.max(phase_diffs) - np.min(phase_diffs),
        'time_delay_mean': np.mean(time_delays),
        'time_delay_std': np.std(time_delays),
        'time_delay_median': np.median(time_delays),
        'time_delay_min': np.min(time_delays),
        'time_delay_max': np.max(time_delays),
        'time_delay_range': np.max(time_delays) - np.min(time_delays),
        'raw_data': {
            'phase_differences': phase_diffs.tolist(),
            'time_delays': time_delays.tolist()
        }
    }
    
    # Format results
    result = f"üìä {signal_type.upper()} CYCLE-BY-CYCLE PHASE ANALYSIS:\n"
    result += f"   üìà Cycle Detection Results:\n"
    result += f"      Total cycles analyzed:     {stats['num_cycles']}\n"
    result += f"      E-field zero crossings:    {len(ch1_zero_crossings)}\n"
    result += f"      Mains zero crossings:      {len(ch3_zero_crossings)}\n"
    
    result += f"\n   üîç Phase Difference Statistics:\n"
    result += f"      Mean:                      {stats['phase_mean']:.3f}¬∞\n"
    result += f"      Standard Deviation:        {stats['phase_std']:.3f}¬∞\n"
    result += f"      Median:                    {stats['phase_median']:.3f}¬∞\n"
    result += f"      Range:                     {stats['phase_min']:.3f}¬∞ to {stats['phase_max']:.3f}¬∞\n"
    result += f"      Total Range:               {stats['phase_range']:.3f}¬∞\n"
    
    result += f"\n   ‚è±Ô∏è  Time Delay Statistics:\n"
    result += f"      Mean:                      {stats['time_delay_mean']:.6f} ms\n"
    result += f"      Standard Deviation:        {stats['time_delay_std']:.6f} ms\n"
    result += f"      Median:                    {stats['time_delay_median']:.6f} ms\n"
    result += f"      Range:                     {stats['time_delay_min']:.6f} to {stats['time_delay_max']:.6f} ms\n"
    result += f"      Total Range:               {stats['time_delay_range']:.6f} ms\n"
    
    # Stability assessment
    result += f"\n   üìä Phase Stability Assessment:\n"
    if stats['phase_std'] < 0.5:
        result += f"      ‚úÖ Excellent phase stability (œÉ < 0.5¬∞)\n"
    elif stats['phase_std'] < 1.0:
        result += f"      ‚úÖ Very good phase stability (œÉ < 1.0¬∞)\n"
    elif stats['phase_std'] < 2.0:
        result += f"      ‚úÖ Good phase stability (œÉ < 2.0¬∞)\n"
    elif stats['phase_std'] < 5.0:
        result += f"      ‚ö†Ô∏è  Moderate phase stability (œÉ < 5.0¬∞)\n"
    else:
        result += f"      ‚ùå Poor phase stability (œÉ > 5.0¬∞) - Check system\n"
    
    # Phase relationship interpretation
    if stats['phase_mean'] > 0:
        result += f"      ‚Üí E-field consistently LEADS mains by {abs(stats['phase_mean']):.1f}¬∞ ¬± {stats['phase_std']:.1f}¬∞\n"
    elif stats['phase_mean'] < 0:
        result += f"      ‚Üí E-field consistently LAGS mains by {abs(stats['phase_mean']):.1f}¬∞ ¬± {stats['phase_std']:.1f}¬∞\n"
    else:
        result += f"      ‚Üí Signals are in phase on average\n"
    
    # Range analysis
    if stats['phase_range'] < 2.0:
        result += f"      ‚Üí Excellent phase consistency (range < 2.0¬∞)\n"
    elif stats['phase_range'] < 5.0:
        result += f"      ‚Üí Good phase consistency (range < 5.0¬∞)\n"
    else:
        result += f"      ‚Üí Significant phase variation (range > 5.0¬∞)\n"
    
    return result, stats

def analyze_raw_signals_direct(ch1_signal, ch3_signal, time_array, signal_type):
    """
    Direct analysis of raw signals without curve fitting - uses cross-correlation for phase measurement.
    """
    from scipy import signal
    
    # Calculate sampling frequency
    fs = 1.0 / np.mean(np.diff(time_array))
    
    # Remove DC components
    ch1_ac = ch1_signal - np.mean(ch1_signal)
    ch3_ac = ch3_signal - np.mean(ch3_signal)
    
    # Cross-correlation to find phase relationship
    correlation = signal.correlate(ch1_ac, ch3_ac, mode='full')
    lags = signal.correlation_lags(len(ch1_ac), len(ch3_ac), mode='full')
    
    # Find peak correlation
    max_corr_idx = np.argmax(np.abs(correlation))
    lag_at_max = lags[max_corr_idx]
    max_correlation = correlation[max_corr_idx]
    
    # Convert lag to time and phase
    time_delay = lag_at_max / fs
    
    # Estimate frequency using FFT
    fft_ch1 = np.fft.rfft(ch1_ac)
    fft_ch3 = np.fft.rfft(ch3_ac)
    freqs = np.fft.rfftfreq(len(ch1_ac), d=1/fs)
    
    # Find dominant frequency
    ch1_peak_idx = np.argmax(np.abs(fft_ch1))
    ch3_peak_idx = np.argmax(np.abs(fft_ch3))
    ch1_freq = freqs[ch1_peak_idx]
    ch3_freq = freqs[ch3_peak_idx]
    
    # Calculate phase difference using dominant frequency
    avg_freq = (ch1_freq + ch3_freq) / 2
    phase_diff_deg = (time_delay * avg_freq * 360) % 360
    
    # Normalize to -180 to +180 range
    if phase_diff_deg > 180:
        phase_diff_deg -= 360
    
    # Calculate correlation coefficient (signal similarity)
    correlation_coeff = np.corrcoef(ch1_ac, ch3_ac)[0, 1]
    
    # Build result string
    result = f"üìä {signal_type.upper()} SIGNAL DIRECT ANALYSIS (No Curve Fitting):\n"
    result += f"   üìä Frequency Analysis (FFT-based):\n"
    result += f"      E-field peak frequency:  {ch1_freq:.6f} Hz\n"
    result += f"      Mains peak frequency:    {ch3_freq:.6f} Hz\n"
    
    freq_diff = abs(ch1_freq - ch3_freq)
    freq_diff_ppm = (freq_diff / avg_freq) * 1e6 if avg_freq > 0 else 0
    result += f"      Frequency difference:   {freq_diff:.6f} Hz ({freq_diff_ppm:.1f} ppm)\n"
    
    if freq_diff_ppm < 10:
        result += f"      ‚úÖ Excellent frequency coherence\n"
    elif freq_diff_ppm < 100:
        result += f"      ‚úÖ Good frequency coherence\n"
    else:
        result += f"      ‚ö†Ô∏è  Frequency difference detected\n"
    
    result += f"\n   üîç Phase Analysis (Cross-Correlation Method):\n"
    result += f"      Cross-correlation time delay: {time_delay*1000:.6f} ms\n"
    result += f"      Phase difference:            {phase_diff_deg:.3f}¬∞ (E-field relative to Mains)\n"
    result += f"      Signal correlation coeff:    {correlation_coeff:.6f}\n"
    
    if abs(phase_diff_deg) < 1:
        result += f"      ‚úÖ Excellent phase alignment (< 1¬∞)\n"
    elif abs(phase_diff_deg) < 10:
        result += f"      ‚úÖ Good phase alignment (< 10¬∞)\n"
    else:
        result += f"      ‚ö†Ô∏è  Significant phase offset detected (> 10¬∞)\n"
    
    # Interpretation
    if phase_diff_deg > 0:
        result += f"      ‚Üí E-field LEADS mains voltage by {abs(phase_diff_deg):.1f}¬∞\n"
    elif phase_diff_deg < 0:
        result += f"      ‚Üí E-field LAGS mains voltage by {abs(phase_diff_deg):.1f}¬∞\n"
    else:
        result += f"      ‚Üí Perfect phase alignment\n"
    
    result += f"\n   üìà Signal Quality (Direct Measurements):\n"
    result += f"      E-field RMS:              {rms(ch1_signal):.6f} V\n"
    result += f"      Mains RMS:                {rms(ch3_signal):.3f} V\n"
    result += f"      E-field peak-to-peak:     {np.ptp(ch1_signal):.6f} V\n"
    result += f"      Mains peak-to-peak:       {np.ptp(ch3_signal):.3f} V\n"
    
    if correlation_coeff > 0.9:
        result += f"      ‚úÖ Excellent signal correlation ({correlation_coeff:.3f})\n"
    elif correlation_coeff > 0.7:
        result += f"      ‚úÖ Good signal correlation ({correlation_coeff:.3f})\n"
    else:
        result += f"      ‚ö†Ô∏è  Moderate signal correlation ({correlation_coeff:.3f})\n"
    
    # Return both the formatted result and raw values for comparison
    return result, {
        'phase_diff_deg': phase_diff_deg,
        'time_delay_ms': time_delay * 1000,
        'freq_diff_ppm': freq_diff_ppm,
        'correlation_coeff': correlation_coeff,
        'ch1_freq': ch1_freq,
        'ch3_freq': ch3_freq
    }

def analyze_signal_pair(params_ch1, params_ch3, signal_type, ch1_signal=None, ch3_signal=None):
    """
    Analyze a pair of signals (E-field and Mains) and return formatted results.
    """
    if not (params_ch1['fit_success'] and params_ch3['fit_success']):
        return f"‚ùå {signal_type} sine fitting failed for one or both signals"
    
    # Calculate phase difference
    e_field_phase_deg = math.degrees(params_ch1['phase'])
    mains_phase_deg = math.degrees(params_ch3['phase'])
    phase_difference = e_field_phase_deg - mains_phase_deg
    
    # Normalize phase difference to -180 to +180 range
    while phase_difference > 180:
        phase_difference -= 360
    while phase_difference < -180:
        phase_difference += 360
    
    # Calculate frequency difference
    freq_diff = abs(params_ch1['frequency'] - params_ch3['frequency'])
    freq_diff_ppm = (freq_diff / params_ch1['frequency']) * 1e6 if params_ch1['frequency'] > 0 else 0
    
    # Calculate time delay equivalent
    time_delay_ms = (abs(phase_difference) / 360.0) * (1000.0 / params_ch1['frequency'])
    
    # Build result string
    result = f"üìä {signal_type.upper()} SIGNAL ANALYSIS:\n"
    result += f"   üìä Frequency Analysis:\n"
    result += f"      E-field frequency:    {params_ch1['frequency']:.6f} Hz\n"
    result += f"      Mains frequency:      {params_ch3['frequency']:.6f} Hz\n"
    result += f"      Frequency difference: {freq_diff:.6f} Hz ({freq_diff_ppm:.1f} ppm)\n"
    
    if freq_diff_ppm < 10:
        result += f"      ‚úÖ Excellent frequency coherence\n"
    elif freq_diff_ppm < 100:
        result += f"      ‚úÖ Good frequency coherence\n"
    else:
        result += f"      ‚ö†Ô∏è  Frequency difference detected\n"
    
    result += f"\n   üîç Phase Relationship Analysis:\n"
    result += f"      Raw fitted phases (relative to t=0 start):\n"
    result += f"        E-field phase:      {e_field_phase_deg:.3f}¬∞\n"
    result += f"        Mains phase:        {mains_phase_deg:.3f}¬∞\n"
    result += f"      \n"
    result += f"      STEADY-STATE PHASE RELATIONSHIP:\n"
    result += f"      Phase difference:       {phase_difference:.3f}¬∞ (E-field - Mains)\n"
    result += f"      This is a CONSTANT offset - not worst case or uncertainty\n"
    
    if abs(phase_difference) < 1:
        result += f"      ‚úÖ Excellent phase alignment (< 1¬∞)\n"
    elif abs(phase_difference) < 10:
        result += f"      ‚úÖ Good phase alignment (< 10¬∞)\n"
    else:
        result += f"      ‚ö†Ô∏è  Significant phase offset detected (> 10¬∞)\n"
    
    # Interpretation with better explanation
    if phase_difference > 0:
        result += f"      ‚Üí E-field signal consistently LEADS mains by {abs(phase_difference):.1f}¬∞\n"
    elif phase_difference < 0:
        result += f"      ‚Üí E-field signal consistently LAGS mains by {abs(phase_difference):.1f}¬∞\n"
    else:
        result += f"      ‚Üí Perfect phase alignment (signals in phase)\n"
        
    # Add timing interpretation
    result += f"      ‚Üí Time equivalent: {time_delay_ms:.3f} ms delay\n"
    result += f"      ‚Üí This represents the sensor's inherent response delay\n"
    
    # Signal quality metrics
    result += f"\n   üìà Signal Quality:\n"
    result += f"      E-field amplitude:    {abs(params_ch1['amplitude']):.6f} V\n"
    result += f"      Mains amplitude:      {abs(params_ch3['amplitude']):.3f} V\n"
    
    if ch1_signal is not None and ch3_signal is not None:
        result += f"      E-field RMS:          {rms(ch1_signal):.6f} V\n"
        result += f"      Mains RMS:            {rms(ch3_signal):.3f} V\n"
    
    return result

def plot_signals(time, raw_signals, filtered_signals, fitted_params, downsample_factor):
    # Create figure with subplots
    fig, axs = plt.subplots(4, 1, figsize=(12, 10), sharex=True)
    # Update channel names to reflect actual setup
    channels = ['E-field Sensor (Ch1)', 'N/A (Ch2)', 'Mains Voltage (Ch3)']
    colors = ['tab:blue', 'tab:orange', 'tab:green']
    
    # Only process channels 1 and 3 (the ones we actually have)
    active_channels = [0, 2]  # Ch1 and Ch3 indices
    
    # Initialize global variables for info panel state
    global info_panel_visible, draggable_info_panel
    info_panel_visible = True
    
    # 1st subplot: Raw signals with separate y-axes
    ax1_left = axs[0]
    ax1_right = ax1_left.twinx()
    
    # Mains voltage (Ch3) on left axis
    line1 = ax1_left.plot(time, raw_signals[2], color=colors[2], label=channels[2])
    ax1_left.set_ylabel('Mains Voltage (V)', color=colors[2])
    ax1_left.tick_params(axis='y', labelcolor=colors[2])
    
    # E-field sensor (Ch1) on right axis
    line2 = ax1_right.plot(time, raw_signals[0], color=colors[0], label=channels[0])
    ax1_right.set_ylabel('E-field Voltage (V)', color=colors[0])
    ax1_right.tick_params(axis='y', labelcolor=colors[0])
    
    # Combined legend
    lines = line1 + line2
    labels = [l.get_label() for l in lines]
    ax1_left.legend(lines, labels, loc='upper right')
    ax1_left.set_title('Raw Signals - Mains (left) vs E-field (right)')
    ax1_left.grid(True)

    # 2nd subplot: Fitted sine signals with separate y-axes
    ax2_left = axs[1]
    ax2_right = ax2_left.twinx()
    
    # Mains voltage fitted curve on left axis
    if fitted_params[2]['fit_success']:
        fitted_curve_mains = sine_function(time,
                                          fitted_params[2]['amplitude'],
                                          fitted_params[2]['frequency'],
                                          fitted_params[2]['phase'],
                                          fitted_params[2]['offset'])
        line3 = ax2_left.plot(time, fitted_curve_mains, color=colors[2], label=channels[2])
        ax2_left.set_ylabel('Mains Voltage (V)', color=colors[2])
        ax2_left.tick_params(axis='y', labelcolor=colors[2])
    
    # E-field fitted curve on right axis
    if fitted_params[0]['fit_success']:
        fitted_curve_efield = sine_function(time,
                                           fitted_params[0]['amplitude'],
                                           fitted_params[0]['frequency'],
                                           fitted_params[0]['phase'],
                                           fitted_params[0]['offset'])
        line4 = ax2_right.plot(time, fitted_curve_efield, color=colors[0], label=channels[0])
        ax2_right.set_ylabel('E-field Voltage (V)', color=colors[0])
        ax2_right.tick_params(axis='y', labelcolor=colors[0])
    
    # Combined legend for fitted signals
    if fitted_params[2]['fit_success'] and fitted_params[0]['fit_success']:
        lines_fitted = line3 + line4
        labels_fitted = [l.get_label() for l in lines_fitted]
        ax2_left.legend(lines_fitted, labels_fitted, loc='upper right')
    
    ax2_left.set_title('Fitted Sine Signals - Mains (left) vs E-field (right)')
    ax2_left.grid(True)

    # Subplots 3,4: Individual channel detailed plots (raw, filtered, fitted)
    for idx, i in enumerate(active_channels):
        axs[idx+2].plot(time, raw_signals[i], color=colors[i], alpha=0.5, label='Raw')
        axs[idx+2].plot(time, filtered_signals[i], color=colors[i], linestyle='--', label='Filtered')
        if fitted_params[i]['fit_success']:
            fit_curve = sine_function(time,
                                      fitted_params[i]['amplitude'],
                                      fitted_params[i]['frequency'],
                                      fitted_params[i]['phase'],
                                      fitted_params[i]['offset'])
            axs[idx+2].plot(time, fit_curve, color=colors[i], linestyle='-', alpha=0.7, label='Fitted Sine')
        axs[idx+2].set_ylabel(f"{channels[i]} (V)")
        axs[idx+2].legend()
        axs[idx+2].grid(True)

    axs[-1].set_xlabel(f'Time (s) - Downsample factor {downsample_factor}')

    # Calculate mains voltage phase as reference (0¬∞)
    mains_reference_phase_deg = 0.0
    if fitted_params[2]['fit_success']:  # Ch3 is mains voltage
        mains_reference_phase_deg = math.degrees(fitted_params[2]['phase'])
    
    # Create textual summary with fitted results and metrics (only for active channels)
    text_str = ""
    for i in active_channels:
        p = fitted_params[i]
        if p['phase'] is not None:
            phase_deg = math.degrees(p['phase'])
            # Adjust phase relative to mains voltage reference
            if i == 2:  # Ch3 - mains voltage (reference)
                relative_phase_deg = 0.0
            else:  # Ch1 - E-field sensor
                relative_phase_deg = phase_deg - mains_reference_phase_deg
                # Normalize to -180 to +180 range
                while relative_phase_deg > 180:
                    relative_phase_deg -= 360
                while relative_phase_deg < -180:
                    relative_phase_deg += 360
        else:
            relative_phase_deg = float('nan')

        text_str += (f"{channels[i]}:\n"
                    f"Freq: {p['frequency']:.3f} Hz\n"
                    f"Amplitude: {p['amplitude']:.3f} V\n"
                    f"Phase: {relative_phase_deg:.3f}¬∞\n"
                    f"RMS: {rms(filtered_signals[i]):.3f} V\n"
                    f"Fit: {'‚úì' if p['fit_success'] else '‚úó'}\n\n")

    # Key phase relationship: E-field sensor (Ch1) vs Mains voltage (Ch3)
    if fitted_params[0]['fit_success'] and fitted_params[2]['fit_success']:
        e_field_phase = math.degrees(fitted_params[0]['phase'])
        mains_phase = math.degrees(fitted_params[2]['phase'])
        phase_diff = mains_phase - e_field_phase
        
        # Normalize phase difference to -180 to +180 range
        while phase_diff > 180:
            phase_diff -= 360
        while phase_diff < -180:
            phase_diff += 360
            
        text_str += f"=== PHASE ANALYSIS ===\n"
        text_str += f"Mains - E-field:\n{phase_diff:.1f}¬∞ lag\n\n"
        
        # Add frequency comparison
        freq_ratio = fitted_params[2]['frequency'] / fitted_params[0]['frequency']
        text_str += f"Frequency ratio:\n{freq_ratio:.3f} (Mains/E-field)"

    # Create draggable info panel
    class DraggableInfoPanel:
        def __init__(self, fig, info_text):
            self.fig = fig
            self.info_text = info_text
            self.visible = True
            self.press = None
            
            # Create the text annotation - positioned initially on right side
            self.annotation = fig.text(0.02, 0.98, info_text, 
                                     fontsize=9, va='top', ha='left',
                                     fontfamily='monospace',
                                     bbox=dict(facecolor='white', alpha=0.9, 
                                              edgecolor='gray', linewidth=1, pad=5),
                                     transform=fig.transFigure)
            
            # Make it draggable
            self.annotation.set_picker(True)
            
        def connect(self):
            """Connect to matplotlib events"""
            self.cidpress = self.annotation.figure.canvas.mpl_connect('button_press_event', self.on_press)
            self.cidrelease = self.annotation.figure.canvas.mpl_connect('button_release_event', self.on_release)
            self.cidmotion = self.annotation.figure.canvas.mpl_connect('motion_notify_event', self.on_motion)
            self.cidkey = self.annotation.figure.canvas.mpl_connect('key_press_event', self.on_key)
            
        def on_press(self, event):
            """Handle mouse press for dragging"""
            contains, _ = self.annotation.contains(event)
            if not contains:
                return
            # Store initial position and event coordinates in figure coordinates
            self.press = (self.annotation.get_position(), event.x, event.y)
            
        def on_motion(self, event):
            """Handle mouse motion for dragging"""
            if self.press is None:
                return
                
            # Calculate new position in figure coordinates
            pos, xpress, ypress = self.press
            
            # Convert pixel movement to figure coordinate movement
            fig_width = self.fig.get_figwidth() * self.fig.dpi
            fig_height = self.fig.get_figheight() * self.fig.dpi
            
            dx = (event.x - xpress) / fig_width if event.x else 0
            dy = (event.y - ypress) / fig_height if event.y else 0
            
            # Calculate new position and constrain to figure bounds
            new_x = max(0, min(0.95, pos[0] + dx))  # Leave some margin
            new_y = max(0.05, min(0.95, pos[1] + dy))
            
            self.annotation.set_position((new_x, new_y))
            self.fig.canvas.draw_idle()
            
        def on_release(self, event):
            """Handle mouse release"""
            self.press = None
            self.fig.canvas.draw_idle()
            
        def on_key(self, event):
            """Handle keyboard shortcuts"""
            if event.key == 'i' or event.key == 'I':  # Toggle info panel
                self.toggle_visibility()
            elif event.key == 'r' or event.key == 'R':  # Reset position
                self.reset_position()
                
        def toggle_visibility(self):
            """Toggle info panel visibility"""
            self.visible = not self.visible
            self.annotation.set_visible(self.visible)
            self.fig.canvas.draw_idle()
            print(f"Info panel {'shown' if self.visible else 'hidden'}")
            
        def reset_position(self):
            """Reset info panel to original position"""
            self.annotation.set_position((0.02, 0.98))
            self.fig.canvas.draw_idle()
            print("Info panel position reset")
    
    # Format the info text nicely
    wrapper = textwrap.TextWrapper(width=35)
    wrapped_text = wrapper.fill(text_str)
    
    # Create and setup the draggable info panel
    info_panel = DraggableInfoPanel(fig, wrapped_text)
    info_panel.connect()
    
    # Optimize layout - use more space for plots, less for margins
    plt.tight_layout(rect=[0, 0.02, 1, 0.98])  # Maximized plot area
    
    # Print help to console before showing plot
    print("\n=== INTERACTIVE PLOT CONTROLS ===")
    print("PLOT NAVIGATION:")
    print("‚Ä¢ Use the toolbar buttons to navigate the plots")
    print("‚Ä¢ Pan tool: Click and drag to move around the plot")
    print("‚Ä¢ Zoom tool: Click to zoom in, right-click to zoom out")
    print("‚Ä¢ Home button: Reset to original view")
    print("‚Ä¢ Back/Forward: Navigate through zoom/pan history")
    print("‚Ä¢ Configure: Adjust subplot spacing and margins")
    print("‚Ä¢ Each subplot can be navigated independently")
    print("\nINFO PANEL CONTROLS:")
    print("‚Ä¢ CLICK and DRAG the info panel to move it around")
    print("‚Ä¢ Press 'I' key to hide/show the info panel")
    print("‚Ä¢ Press 'R' key to reset info panel to top-left corner")
    print("‚Ä¢ Info panel shows analysis results and phase data")
    print("\nGENERAL:")
    print("‚Ä¢ Close the plot window when done viewing")
    print("‚Ä¢ Press Ctrl+C in terminal to exit if needed")
    print("‚Ä¢ Focus the plot window to use keyboard shortcuts")
    print("=====================================\n")
    
    # Show plot with blocking mode to keep window open
    plt.ioff()  # Turn off interactive mode for blocking display
    plt.show(block=True)  # Block until window is closed
    
    print("Plot window closed. Analysis complete.")

def read_siglent_binary_data(directory=BINARY_DATA_DIR):
    """
    Read Siglent oscilloscope binary data files.
    
    Args:
        directory: Directory containing binary data files
        
    Returns:
        Tuple of (time_array, [ch1_data, ch2_data, ch3_data])
    """
    if not SIGLENT_PARSER_AVAILABLE:
        raise ImportError("siglent_parser module not available. Run the parser separately first.")
        
    parser = SiglentBinaryParser()
    channels = parser.parse_directory(directory)
    
    # Verify we have the channels we need
    needed_channels = ['C1', 'C3']
    missing = [ch for ch in needed_channels if ch not in channels]
    if missing:
        raise ValueError(f"Missing required channels: {', '.join(missing)}")
        
    # Get time array from C1 (should be the same for all channels)
    time_array = channels['C1'].get_time_array(
        parser.header.time_div,
        parser.header.time_delay,
        parser.header.sample_rate,
        parser.header.hori_div_num
    )
    
    # Get channel data - align with expected order: C1, C2, C3
    ch_data = []
    for ch_name in ['C1', 'C2', 'C3']:
        if ch_name in channels:
            ch_data.append(channels[ch_name].voltage_data)
        else:
            # If channel missing (e.g., C2), insert zeros
            ch_data.append(np.zeros_like(time_array))
    
    return time_array, ch_data

# --- Main processing ---

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="E-field sensor data analysis")
    parser.add_argument("--binary", action="store_true", help="Use Siglent binary data instead of CSV")
    parser.add_argument("--csv", type=str, help="CSV file path", default=CSV_FILE)
    parser.add_argument("--binary-dir", type=str, help="Directory with binary files", default=BINARY_DATA_DIR)
    
    # Cycle analysis options
    parser.add_argument("--no-cycle-analysis", action="store_true", help="Disable cycle-by-cycle statistical analysis")
    parser.add_argument("--cycle-method", type=str, choices=['zero_crossing', 'peak_to_peak'], 
                       default=CYCLE_DETECTION_METHOD, help="Cycle detection method")
    parser.add_argument("--expected-freq", type=float, help="Expected fundamental frequency in Hz (auto-detected if not specified)")
    
    args = parser.parse_args()

    # 1. Read data - either from CSV or binary files
    if args.binary and SIGLENT_PARSER_AVAILABLE:
        print(f"Reading Siglent binary data from {args.binary_dir}...")
        time, [ch1, ch2, ch3] = read_siglent_binary_data(args.binary_dir)
    else:
        if args.binary and not SIGLENT_PARSER_AVAILABLE:
            print("Warning: Siglent binary parser not available. Falling back to CSV.")
        print(f"Reading CSV data from {args.csv}...")
        data = read_oscilloscope_csv(args.csv)
        # Extract time and signals as floats from columns
        time = data['Second'].astype(float).values
        ch1 = data['Volt'].astype(float).values   # Channel 1 voltage
        ch2 = data.iloc[:, 2].astype(float).values  # Channel 2 voltage (E-field)
        ch3 = data.iloc[:, 3].astype(float).values  # Channel 3 voltage (E-field)

    # 2. Apply scaling factors to channels (currently no amplification needed)
    ch1_scaled = amplify_signal(ch1, AMPLIFICATION_CH1)  # E-field sensor
    ch2_scaled = amplify_signal(ch2, 1)  # Ch2 not used, keep as zeros
    ch3_scaled = amplify_signal(ch3, AMPLIFICATION_CH3)  # Mains voltage

    # 3. Downsample time and signals to speed processing
    time_ds = downsample_signal(time, DOWNSAMPLE_FACTOR)
    ch1_ds = downsample_signal(ch1_scaled, DOWNSAMPLE_FACTOR)
    ch2_ds = downsample_signal(ch2_scaled, DOWNSAMPLE_FACTOR)
    ch3_ds = downsample_signal(ch3_scaled, DOWNSAMPLE_FACTOR)

    # Sampling frequency from downsampled time vector
    fs = 1 / np.mean(np.diff(time_ds))

    # 4. Apply zero-phase Butterworth lowpass filter to remove noise
    ch1_filt = zero_phase_filter(ch1_ds, fs, cutoff=FILTER_CUTOFF_HZ, order=FILTER_ORDER)
    ch2_filt = zero_phase_filter(ch2_ds, fs, cutoff=FILTER_CUTOFF_HZ, order=FILTER_ORDER)
    ch3_filt = zero_phase_filter(ch3_ds, fs, cutoff=FILTER_CUTOFF_HZ, order=FILTER_ORDER)

    # 5. Fit sine functions to raw, filtered, and generate analysis
    # Raw signal fitting
    params_ch1_raw = fit_sine_to_signal(time_ds, ch1_ds)
    params_ch3_raw = fit_sine_to_signal(time_ds, ch3_ds)
    
    # Filtered signal fitting
    params_ch1_filt = fit_sine_to_signal(time_ds, ch1_filt)
    params_ch2_filt = fit_sine_to_signal(time_ds, ch2_filt)
    params_ch3_filt = fit_sine_to_signal(time_ds, ch3_filt)
    
    # Keep original fitted params for compatibility with plotting
    params_ch1 = params_ch1_filt
    params_ch2 = params_ch2_filt
    params_ch3 = params_ch3_filt

    # 6. Display comprehensive signal analysis results
    print("\n" + "="*80)
    print("COMPREHENSIVE E-FIELD SENSOR ANALYSIS")
    print("="*80)
    
    # Direct analysis of raw signals (no curve fitting)
    raw_direct_result, raw_direct_data = analyze_raw_signals_direct(ch1_ds, ch3_ds, time_ds, "RAW")
    print(raw_direct_result)
    print("\n" + "-"*80)
    
    # Curve fitting analysis of raw signals
    print(analyze_signal_pair(params_ch1_raw, params_ch3_raw, "RAW SIGNAL CURVE-FITTED", ch1_ds, ch3_ds))
    print("\n" + "-"*80)
    
    # Curve fitting analysis of filtered signals  
    print(analyze_signal_pair(params_ch1_filt, params_ch3_filt, "FILTERED SIGNAL CURVE-FITTED", ch1_filt, ch3_filt))
    print("\n" + "-"*80)
    
    # Compare direct analysis vs curve fitting for raw signals
    if (params_ch1_raw['fit_success'] and params_ch3_raw['fit_success']):
        raw_curve_phase_diff = math.degrees(params_ch1_raw['phase'] - params_ch3_raw['phase'])
        while raw_curve_phase_diff > 180: raw_curve_phase_diff -= 360
        while raw_curve_phase_diff < -180: raw_curve_phase_diff += 360
        
        print(f"üìä RAW SIGNAL ANALYSIS METHOD COMPARISON:")
        print(f"   Direct Analysis (Cross-Correlation):")
        print(f"     Phase difference:      {raw_direct_data['phase_diff_deg']:.3f}¬∞")
        print(f"     Time delay:           {raw_direct_data['time_delay_ms']:.6f} ms")
        print(f"     Frequency difference: {raw_direct_data['freq_diff_ppm']:.1f} ppm")
        print(f"     Signal correlation:   {raw_direct_data['correlation_coeff']:.6f}")
        
        print(f"\n   Curve Fitting Analysis:")
        print(f"     Phase difference:      {raw_curve_phase_diff:.3f}¬∞")
        print(f"     Time delay:           {abs(raw_curve_phase_diff)/360*1000/params_ch1_raw['frequency']:.6f} ms")
        raw_curve_freq_ppm = abs(params_ch1_raw['frequency'] - params_ch3_raw['frequency']) / params_ch1_raw['frequency'] * 1e6
        print(f"     Frequency difference: {raw_curve_freq_ppm:.1f} ppm")
        
        method_diff = abs(raw_direct_data['phase_diff_deg'] - raw_curve_phase_diff)
        print(f"\n   Method Agreement:")
        print(f"     Phase difference discrepancy: {method_diff:.3f}¬∞")
        
        if method_diff < 1.0:
            print(f"     ‚úÖ Excellent agreement between methods (< 1¬∞)")
        elif method_diff < 5.0:
            print(f"     ‚úÖ Good agreement between methods (< 5¬∞)")
        else:
            print(f"     ‚ö†Ô∏è  Significant discrepancy - investigate signal quality")
            
        # Recommend which method to trust
        if raw_direct_data['correlation_coeff'] > 0.9 and method_diff < 2.0:
            print(f"     üí° Both methods reliable - use curve fitting for precision")
        elif raw_direct_data['correlation_coeff'] < 0.8:
            print(f"     üí° Low signal correlation - curve fitting more reliable")
        else:
            print(f"     üí° Direct analysis captures actual signal behavior better")
    
    print("\n" + "-"*80)
    
    # Zero crossing diagnostic - investigate why cycle-by-cycle analysis fails
    print(f"üîç ZERO CROSSING DIAGNOSTIC:")
    diagnostic_raw = diagnose_zero_crossing_issues(ch1_ds, ch3_ds, time_ds, "RAW SIGNALS")
    
    # Test DC removal methods to fix zero crossing issues
    ch1_clean, ch1_best_method, ch1_dc_info = test_dc_removal_methods(ch1_ds, time_ds, "E-FIELD (Ch1)")
    ch3_clean, ch3_best_method, ch3_dc_info = test_dc_removal_methods(ch3_ds, time_ds, "MAINS (Ch3)")
    
    # Re-run diagnostic on cleaned signals
    print(f"\nüîß POST-DC-REMOVAL DIAGNOSTIC:")
    diagnostic_clean = diagnose_zero_crossing_issues(ch1_clean, ch3_clean, time_ds, "DC-CLEANED SIGNALS")
    
    # Now try cycle analysis with the cleaned signals if they have reasonable zero crossings
    if diagnostic_clean['ch1_crossings'] > 50 and diagnostic_clean['ch3_crossings'] > 50:
        print(f"\nüéâ CYCLE-BY-CYCLE PHASE ANALYSIS (DC-Cleaned Signals):")
        cycle_result_clean, cycle_stats_clean = analyze_cycle_by_cycle_phase(ch1_clean, ch3_clean, time_ds, "DC-CLEANED")
        print(cycle_result_clean)
        
        if cycle_stats_clean:
            print(f"\nüìè DC REMOVAL EFFECTIVENESS COMPARISON:")
            print(f"   Zero Crossing Count Improvement:")
            print(f"     E-field: {diagnostic_raw['ch1_crossings']} ‚Üí {diagnostic_clean['ch1_crossings']} ({diagnostic_clean['ch1_crossings']/diagnostic_raw['ch1_crossings']*100:.1f}% of original)")
            print(f"     Mains:   {diagnostic_raw['ch3_crossings']} ‚Üí {diagnostic_clean['ch3_crossings']} ({diagnostic_clean['ch3_crossings']/diagnostic_raw['ch3_crossings']*100:.1f}% of original)")
            
            print(f"\n   Phase Analysis Improvement:")
            print(f"     DC-Cleaned cycle analysis successful with {cycle_stats_clean['num_cycles']} cycles")
            print(f"     Phase stability: {cycle_stats_clean['phase_std']:.3f}¬∞ (standard deviation)")
            print(f"     Mean phase difference: {cycle_stats_clean['phase_mean']:.3f}¬∞")
            
            # Compare with overall cross-correlation method
            if abs(cycle_stats_clean['phase_mean'] - raw_direct_data['phase_diff_deg']) < 5.0:
                print(f"     ‚úÖ Good agreement with cross-correlation method ({abs(cycle_stats_clean['phase_mean'] - raw_direct_data['phase_diff_deg']):.1f}¬∞ difference)")
            else:
                print(f"     ‚ö†Ô∏è  Some discrepancy with cross-correlation method ({abs(cycle_stats_clean['phase_mean'] - raw_direct_data['phase_diff_deg']):.1f}¬∞ difference)")
    else:
        print(f"\nüö´ DC REMOVAL INSUFFICIENT:")
        print(f"   Even after DC removal, zero crossing counts are still problematic:")
        print(f"     E-field: {diagnostic_clean['ch1_crossings']} (expected ~120)")
        print(f"     Mains: {diagnostic_clean['ch3_crossings']} (expected ~120)")
        print(f"   ‚Üí Consider hardware-level DC coupling or signal conditioning issues")
    
    if diagnostic_raw['ch1_crossings'] > 50 and diagnostic_raw['ch3_crossings'] > 50:
        # Only proceed with cycle analysis if we have reasonable zero crossing counts
        print(f"\nüìä CYCLE-BY-CYCLE PHASE ANALYSIS (Raw Signals):")
        cycle_result_raw, cycle_stats_raw = analyze_cycle_by_cycle_phase(ch1_ds, ch3_ds, time_ds, "RAW")
        print(cycle_result_raw)
        
        if cycle_stats_raw:
            print(f"\nüìä CYCLE-BY-CYCLE PHASE ANALYSIS (Filtered Signals):")
            cycle_result_filt, cycle_stats_filt = analyze_cycle_by_cycle_phase(ch1_filt, ch3_filt, time_ds, "FILTERED")
            print(cycle_result_filt)
            
            # Compare cycle-by-cycle vs overall analysis methods
            if cycle_stats_raw and cycle_stats_filt:
                print(f"\nüìä CYCLE-BY-CYCLE vs OVERALL ANALYSIS COMPARISON:")
                print(f"   Raw Signals:")
                print(f"     Overall Cross-Correlation:   {raw_direct_data['phase_diff_deg']:.3f}¬∞")
                print(f"     Cycle-by-Cycle Mean:         {cycle_stats_raw['phase_mean']:.3f}¬∞ ¬± {cycle_stats_raw['phase_std']:.3f}¬∞")
                print(f"     Method Agreement:            {abs(raw_direct_data['phase_diff_deg'] - cycle_stats_raw['phase_mean']):.3f}¬∞ difference")
                
                print(f"\n   Processing Effects:")
                processing_effect = abs(cycle_stats_filt['phase_mean'] - cycle_stats_raw['phase_mean'])
                stability_change = cycle_stats_filt['phase_std'] - cycle_stats_raw['phase_std']
                print(f"     Phase change (Raw ‚Üí Filtered):  {processing_effect:.3f}¬∞")
                print(f"     Stability change:              {stability_change:+.3f}¬∞ (œÉ)")
                
                if abs(stability_change) < 0.1:
                    print(f"     ‚úÖ Filtering had minimal effect on phase stability")
                elif stability_change < -0.1:
                    print(f"     ‚úÖ Filtering improved phase stability by {abs(stability_change):.3f}¬∞")
                else:
                    print(f"     ‚ö†Ô∏è  Filtering reduced phase stability by {stability_change:.3f}¬∞")
    else:
        print(f"\n‚ùå CYCLE-BY-CYCLE ANALYSIS SKIPPED:")
        print(f"   Insufficient zero crossings detected for reliable cycle analysis")
        print(f"   E-field: {diagnostic_raw['ch1_crossings']} crossings (expected ~120 for 1-second at 60Hz)")
        print(f"   Mains: {diagnostic_raw['ch3_crossings']} crossings (expected ~120 for 1-second at 60Hz)")
        print(f"   ‚Üí Check signal quality, amplitude, and DC offset issues identified above")
    
    print("\n" + "-"*80)
    
    # Summary comparison
    if (params_ch1_raw['fit_success'] and params_ch3_raw['fit_success'] and 
        params_ch1_filt['fit_success'] and params_ch3_filt['fit_success']):
        
        # Calculate phase differences for comparison
        raw_phase_diff = math.degrees(params_ch1_raw['phase'] - params_ch3_raw['phase'])
        filt_phase_diff = math.degrees(params_ch1_filt['phase'] - params_ch3_filt['phase'])
        
        # Normalize phase differences
        while raw_phase_diff > 180: raw_phase_diff -= 360
        while raw_phase_diff < -180: raw_phase_diff += 360
        while filt_phase_diff > 180: filt_phase_diff -= 360
        while filt_phase_diff < -180: filt_phase_diff += 360
        
        print(f"üìä PROCESSING EFFECTS SUMMARY:")
        print(f"   Phase Difference Comparison:")
        print(f"     Raw signals:       {raw_phase_diff:.3f}¬∞")
        print(f"     Filtered signals:  {filt_phase_diff:.3f}¬∞")
        print(f"     Filtering effect:  {abs(filt_phase_diff - raw_phase_diff):.3f}¬∞ change")
        
        # Frequency stability comparison
        raw_freq_diff_ppm = abs(params_ch1_raw['frequency'] - params_ch3_raw['frequency']) / params_ch1_raw['frequency'] * 1e6
        filt_freq_diff_ppm = abs(params_ch1_filt['frequency'] - params_ch3_filt['frequency']) / params_ch1_filt['frequency'] * 1e6
        
        print(f"\n   Frequency Coherence Comparison:")
        print(f"     Raw signals:       {raw_freq_diff_ppm:.1f} ppm")
        print(f"     Filtered signals:  {filt_freq_diff_ppm:.1f} ppm")
        
        if filt_freq_diff_ppm < raw_freq_diff_ppm:
            improvement = ((raw_freq_diff_ppm - filt_freq_diff_ppm) / raw_freq_diff_ppm) * 100
            print(f"     ‚úÖ Filtering improved coherence by {improvement:.1f}%")
        else:
            print(f"     ‚ö†Ô∏è  Filtering did not improve coherence")
        
        # Final recommendation
        print(f"\nüéÜ FINAL SENSOR PERFORMANCE ASSESSMENT:")
        if abs(filt_phase_diff) < 10 and filt_freq_diff_ppm < 100:
            print(f"   ‚úÖ EXCELLENT: Your E-field sensor shows excellent performance")
            print(f"   ‚Üí Stable {abs(filt_phase_diff):.1f}¬∞ phase relationship with mains voltage")
            print(f"   ‚Üí Excellent frequency tracking ({filt_freq_diff_ppm:.1f} ppm difference)")
        elif abs(filt_phase_diff) < 45 and filt_freq_diff_ppm < 1000:
            print(f"   ‚úÖ GOOD: Your E-field sensor shows good performance")
            print(f"   ‚Üí {abs(filt_phase_diff):.1f}¬∞ phase relationship (acceptable for most applications)")
        else:
            print(f"   ‚ö†Ô∏è  NEEDS ATTENTION: Consider sensor calibration or setup review")
    
    # 7. Plot raw, filtered, and fitted signals; show numerical summary with text wrapping
    plot_signals(time_ds,
                 [ch1_ds, ch2_ds, ch3_ds],
                 [ch1_filt, ch2_filt, ch3_filt],
                 [params_ch1, params_ch2, params_ch3],
                 DOWNSAMPLE_FACTOR)

if __name__ == "__main__":
    main()
